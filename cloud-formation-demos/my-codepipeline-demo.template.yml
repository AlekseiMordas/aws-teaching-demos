AWSTemplateFormatVersion: 2010-09-09

# TO RUN THIS:  You'll need a GitHub Repository, and a GitHub OAuthToken.
# To make a GitHub OAuthToken, go to GitHub / Settings / Personal Access Tokens
# Put a '9' on the front

Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups: 
      - Label: 
          default: "Code Build Pipeline"
        Parameters: 
          - GitHubRepository
          - GitHubOAuthToken
          - CodePipelineBucketPrefix
      - Label: 
          default: "Network Configuration"
        Parameters: 
          - VpcId
          - SubnetIds
      - Label: 
          default: "ECS Cluster"
        Parameters: 
          - MaxSize
          - DesiredCapacity

Parameters:
  CodePipelineBucketPrefix:
    Description: CodePipeline needs a utility bucket.  Specify the prefix for the bucket name
    Type: String
    Default: codepipeline-

  GitHubRepository:
    Type: String
    Default:  kennyk65/aws-cloudbuild-demo/master
    Description:  The owner / repository / branch that you want to pull from.

  GitHubOAuthToken:
    Type: String
    Default:  c5194a2ada94acc7743b7e263132ba0ce1be944
    Description:  CodePipeline sources require an OAuthToken, even if they are public.  To make one go to GitHub / Settings / Personal Access Tokens 

  MaxSize:
    Type: String
    Default: 1
    Description: Maximum number of ECS instances.

  DesiredCapacity:
    Type: String
    Default: 1
    Description: Desired number of ECS instances.

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: Select a VPC that allows instances access to the Internet.

  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Select at least two public subnets in your selected VPC.

Mappings:
  #  This is just the Amazon Linux AMI:
  AmazonLinuxAMI:
    us-east-1:
      AMI: ami-d61027ad
    us-east-2:
      AMI: ami-bb8eaede
    us-west-1:
      AMI: ami-514e6431
    us-west-2:
      AMI: ami-c6f81abe
    eu-west-1:
      AMI: ami-bd7e8dc4
    eu-central-1:
      AMI: ami-f15ff69e
    ap-northeast-1:
      AMI: ami-ab5ea9cd
    ap-southeast-1:
      AMI: ami-ae0b91cd
    ap-southeast-2:
      AMI: ami-5781be34


Resources:

  # This Role allows CodeBuild to do certain things on our behalf.
  # See the policy for the interesting stuff:
  CodeBuildRole:
    Type: "AWS::IAM::Role"
    Properties: 
      RoleName: CodeBuildRole  
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement: 
          Effect: "Allow"
          Principal:
            Service: "codebuild.amazonaws.com"
          Action: "sts:AssumeRole"

  # This Role allows CodePipeline to make certain things on our behalf:
  # See the policy for the interesting stuff:
  CodePipelineRole:
    Type: "AWS::IAM::Role"
    Properties: 
      RoleName: CodePipelineRole  
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement: 
          Effect: "Allow"
          Principal:
            Service: "codepipeline.amazonaws.com"
          Action: "sts:AssumeRole"

  # This Policy is attached to the CodeBuildRole.
  # CodeBuild is allowed carte blanche on S3, CodeBuild, and CloudWatch Logs; could probably be tightened quite a bit.
  CodeBuildPolicy:
    Type: "AWS::IAM::Policy"
    Properties: 
      PolicyName: CodeBuildPolicy
      PolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          Effect: Allow
          Action: 
            - logs:*
            - s3:*
            - codebuild:*
          Resource: "*"
      Roles: 
        -  !Ref CodeBuildRole

  # This Policy is attached to the CodePipelineRole.
  # CodePipeline is allowed carte blanche on S3, CodeBuild, and CloudWatch Logs; could probably be tightened quite a bit.
  CodePipelinePolicy:
    Type: "AWS::IAM::Policy"
    Properties: 
      PolicyName: CodePipelinePolicy
      PolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          Effect: Allow
          # I can't quite determine which S3 permission CodePipeline wants.  The one-click policy grants everything...
          # codebuild probably does not need to be wide open like this, and the logs should only need
          # to create the stream, group, and log events.
          Action: 
            - s3:*
            - codebuild:*
            - logs:*
          Resource: 
            - "*"
      Roles: 
        -  !Ref CodePipelineRole

  # General Bucket where CodePipeline will store things:
  S3:
    Type: "AWS::S3::Bucket"
    Properties: 
      BucketName: !Join [ "", [!Ref CodePipelineBucketPrefix, !Ref "AWS::Region", "-", !Ref "AWS::AccountId"]]

  # The CodeBuild project that will be referenced in the CodePipeline below.
  # Fortunately, its configuration is quite small because it is part of a larger
  # Pipeline, so no need for details on Source and Artifacts.  Most of the details
  # on how to to the build itself is in the project's buildspec: https://github.com/kennyk65/aws-cloudbuild-demo/blob/master/buildspec.yml
  MyBuild:
    Type: "AWS::CodeBuild::Project"
    Properties: 
      Name: MyBuild
      Description: Demo of CodeBuild with CodeDeploy pipeline.
      Source:
        Type: CODEPIPELINE
      Artifacts:
        Type: CODEPIPELINE       
      Environment:
        Type: "LINUX_CONTAINER"
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/java:openjdk-8
        PrivilegedMode: false
      ServiceRole: !Ref CodeBuildRole
      TimeoutInMinutes: 5


  # This is the CodePipeline with its stages:
  MyPipe:
    Type: "AWS::CodePipeline::Pipeline"
    Properties:
      Name: MyPipe
      ArtifactStore: 
        Location: !Ref S3
        Type: S3
      RestartExecutionOnUpdate: true
      RoleArn: !Join [ "", ["arn:aws:iam::", !Ref "AWS::AccountId", ":role/", !Ref CodePipelineRole  ] ]  # Would be a lot easier if it didn't have to be in ARN form...
      Stages: 
        # Stage 1:  Get the source from GitHub:
        - Name: Source
          Actions: 
            - Name: SourceAction
              RunOrder: 1
              ActionTypeId: 
                Category: Source
                Owner: ThirdParty       
                Provider: GitHub        
                Version: 1              # Don't know the purpose of 'version'
              Configuration: 
                Owner: !Select [0, !Split [ "/" , !Ref GitHubRepository ]]
                Repo: !Select [1, !Split [ "/" , !Ref GitHubRepository ]]
                Branch: !Select [2, !Split [ "/" , !Ref GitHubRepository ]]
                PollForSourceChanges: true   # Don't know if/how to control frequency
                OAuthToken: !Ref GitHubOAuthToken     # Public repository, Don't know why AWS needs this
              OutputArtifacts: 
                - Name: TheSourceCode
        # Stage 2:  Build using CodeBuild:
        - Name: Build
          Actions: 
            - Name: Build
              RunOrder: 1
              InputArtifacts: 
                - Name: TheSourceCode       # Duh, the output from the previous step.
              ActionTypeId: 
                Category: Build
                Owner: AWS       
                Provider: CodeBuild        
                Version: 1                  # Don't know the purpose of 'version'
              Configuration:
                ProjectName:  !Ref MyBuild  # See the CodeBuild definition above.       
              OutputArtifacts: 
                - Name: TheArtifact

  # Now, an ECS Cluster to deploy to:
  ECSCluster:
    Type: AWS::ECS::Cluster

  # Security Group for the ECS instances.  Allow inbound ports for the ELB to use:
  EcsSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ECS Security Group
      VpcId: !Ref 'VpcId'

  #  Inbound rules for HTTP on 80 plus anything above 31000:
  EcsSecurityGroupHTTPinbound:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'EcsSecurityGroup'
      IpProtocol: tcp
      FromPort: '80'
      ToPort: '80'
      CidrIp: 0.0.0.0/0
  EcsSecurityGroupALBports:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'EcsSecurityGroup'
      IpProtocol: tcp
      FromPort: '31000'
      ToPort: '61000'
      SourceSecurityGroupId: !Ref 'EcsSecurityGroup'

  # This LogsGroup will be useful when several containers emit output:
  CloudwatchLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['-', [ECSLogGroup, !Ref 'AWS::StackName']]
      RetentionInDays: 14

  # This TaskDefinition defines the image we want to run on ECS
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Join ['', [!Ref 'AWS::StackName', -ecs-demo-app]]
      ContainerDefinitions:
      - Name: simple-app
        Cpu: 10
        Essential: true
        Image: httpd:2.4
        Memory: '300'
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group: !Ref CloudwatchLogsGroup
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs-demo-app
        MountPoints:
        - ContainerPath: /usr/local/apache2/htdocs
          SourceVolume: my-vol
        PortMappings:
        - ContainerPort: 80
      - Name: busybox
        Cpu: 10
        Command: ['/bin/sh -c "while true; do echo ''<html> <head> <title>Amazon ECS
            Sample App</title> <style>body {margin-top: 40px; background-color: #333;}
            </style> </head><body> <div style=color:white;text-align:center> <h1>Amazon
            ECS Sample App</h1> <h2>Congratulations!</h2> <p>Your application is now
            running on a container in Amazon ECS.</p>'' > top; /bin/date > date ;
            echo ''</div></body></html>'' > bottom; cat top date bottom > /usr/local/apache2/htdocs/index.html
            ; sleep 1; done"']
        EntryPoint: [sh, -c]
        Essential: false
        Image: busybox
        Memory: 200
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group: !Ref CloudwatchLogsGroup
            awslogs-region: !Ref AWS::Region
            awslogs-stream-prefix: ecs-demo-app
        VolumesFrom:
        - SourceContainer: simple-app
      Volumes:
      - Name: my-vol      


  # Now the Load Balancer, with all of its sub-components:
  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: ALB
      Scheme: internet-facing
      Subnets: !Ref SubnetIds
      SecurityGroups: [!Ref EcsSecurityGroup]
  # Listen on port 80, pass traffic to the TargetGroup:
  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    # DependsOn: ECSServiceRole
    Properties:
      Port: '80'
      Protocol: HTTP
      LoadBalancerArn: !Ref ALB
      DefaultActions:
      - Type: forward
        TargetGroupArn: !Ref ALBTargetGroup
  # The rule is simple; all traffic to "/" goes to our one and only target group:      
  ALBListenerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      ListenerArn: !Ref ALBListener
      Actions:
      - Type: forward
        TargetGroupArn: !Ref ALBTargetGroup
      Conditions:
      - Field: path-pattern
        Values: [/]
      Priority: 1
  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    # DependsOn: ECSALB
    Properties:
      Name: ALBTargetGroup
      VpcId: !Ref VpcId
      Port: 80
      Protocol: HTTP
      HealthCheckProtocol: HTTP
      HealthCheckPath: /
      HealthCheckIntervalSeconds: 10
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 2


  # Auto-Scaling Group for the cluser:
  ECSAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier: !Ref SubnetIds
      LaunchConfigurationName: !Ref ContainerInstances
      MinSize: 1
      MaxSize: !Ref MaxSize
      DesiredCapacity: !Ref DesiredCapacity
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    UpdatePolicy:
      AutoScalingReplacingUpdate:
        WillReplace: true

  # The LaunchConfiguration for the cluster:      
  ContainerInstances:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      ImageId: !FindInMap [AmazonLinuxAMI, !Ref 'AWS::Region', AMI]
      SecurityGroups: [!Ref EcsSecurityGroup]
      InstanceType: t2.micro
      IamInstanceProfile: !Ref EC2InstanceProfile
      # KeyName: !Ref KeyName
      Tags:
      - Key: Name
        Value: ECS Cluster Node
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash -xe
          echo ECS_CLUSTER=${ECSCluster} >> /etc/ecs/ecs.config
          yum install -y aws-cfn-bootstrap
          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ECSAutoScalingGroup --region ${AWS::Region}

  ECSService:
    Type: AWS::ECS::Service
    DependsOn: ALBListener
    Properties:
      Role: !Ref ECSServiceRole
      Cluster: !Ref ECSCluster
      TaskDefinition: !Ref TaskDefinition
      DesiredCount: 1
      LoadBalancers:
      - ContainerName: simple-app
        ContainerPort: 80
        TargetGroupArn: !Ref ALBTargetGroup

  # The IAM Role to be used by the EC2 instances in the ECS cluster.
  # Essential permissions to allow registration / deregistration with load balancer: 
  ECSServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Action: sts:AssumeRole
          Principal:
            Service: ecs.amazonaws.com
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: 
              - elasticloadbalancing:Register*
              - elasticloadbalancing:Deregister*
              - elasticloadbalancing:Describe*
              - ec2:Describe*
              - ec2:AuthorizeSecurityGroupIngress
            Resource: '*'

  AutoscalingRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Action: sts:AssumeRole
          Principal:
            Service: application-autoscaling.amazonaws.com
      Path: /
      Policies:
      - PolicyName: service-autoscaling
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action: 
              - application-autoscaling:*
              - cloudwatch:DescribeAlarms
              - cloudwatch:PutMetricAlarm
              - ecs:DescribeServices
              - ecs:UpdateService
            Resource: '*'

  # I think this is scaling the actual containers:
  ServiceScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    # DependsOn: ECSService
    Properties:
      MinCapacity: 1
      MaxCapacity: 2
      ResourceId: !Join ['', [service/, !Ref 'ECSCluster', /, !GetAtt [ECSService, Name]]]
      RoleARN: !GetAtt [AutoscalingRole, Arn]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
  ServiceScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ServiceScalingPolicy
      PolicyType: StepScaling
      ScalingTargetId: !Ref ServiceScalingTarget
      StepScalingPolicyConfiguration:
        AdjustmentType: PercentChangeInCapacity
        Cooldown: 60
        MetricAggregationType: Average
        StepAdjustments:
        - MetricIntervalLowerBound: 0
          ScalingAdjustment: 200


  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Action: sts:AssumeRole
          Principal:
            Service: ec2.amazonaws.com
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              - ecs:CreateCluster
              - ecs:DeregisterContainerInstance
              - ecs:DiscoverPollEndpoint
              - ecs:Poll
              - ecs:RegisterContainerInstance
              - ecs:StartTelemetrySession
              - ecs:Submit*
              - logs:CreateLogStream
              - logs:PutLogEvents
            Resource: '*'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles: [!Ref 'EC2Role']


Outputs:
  ecsservice:
    Value: !Ref ECSService
  ecscluster:
    Value: !Ref ECSCluster
  ECSALB:
    Description: Your ALB DNS URL
    Value: !Join ['', [!GetAtt [ALB, DNSName]]]
  taskdef:
    Value: !Ref TaskDefinition







